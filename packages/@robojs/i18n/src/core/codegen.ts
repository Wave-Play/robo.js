import { i18nLogger } from './loggers.js'
import { DOT_TOKEN, sanitizeDottedArgs } from './utils.js'
import { parseMessage } from 'messageformat'
import type { Node, TsKind } from './types.js'

/** Produces the TypeScript declaration text for Locale/LocaleKey/LocaleParamsMap from parsed locales. */
export function generateTypes(
	locales: string[],
	keys: string[],
	localeValues: Record<string, Record<string, string | string[]>>
): string {
	const paramsByKey: Record<string, Node> = {}
	const shapeByKey: Record<string, 'string' | 'array' | 'mixed'> = {}

	function addPath(key: string, dotted: string, kind: TsKind) {
		const root = (paramsByKey[key] ||= {})
		const parts = dotted.split('.')
		let node = root

		for (let i = 0; i < parts.length; i++) {
			const part = parts[i]!
			node.children ||= {}
			node = node.children[part] ||= {}

			if (i === parts.length - 1) {
				node.kind = widen(node.kind, kind)
			}
		}
	}

	const noteVarName = (key: string, name: string, kind: TsKind) => {
		// strip an accidental leading '$' if present (regex pass captures without it already)
		const clean = name.startsWith('$') ? name.slice(1) : name
		addPath(key, undot(clean), kind)
	}

	// MF2 regex helpers on the *sanitized* message
	const ANY_VAR_RE = /\{\s*\$([^\s:}]+)\s*(?:[:}])/g // captures both typed & untyped variables
	const NUMERIC_RE = /\{\s*\$([^\s:}]+)\s*:(?:number|integer|decimal|cardinal|ordinal)\b/g
	const DATETIME_RE = /\{\s*\$([^\s:}]+)\s*:(?:datetime|date|time)\b/g

	const analyze = (msg: string, key: string) => {
		// Validate MF2 syntax (throws on invalid); result AST not needed further
		parseMessage(msg)

		// 1) Default: record every variable as string (covers untyped placeholders)
		for (const m of msg.matchAll(ANY_VAR_RE)) {
			noteVarName(key, m[1]!, 'string')
		}

		// 2) Upgrades: apply stronger types when explicitly typed
		for (const m of msg.matchAll(NUMERIC_RE)) {
			noteVarName(key, m[1]!, 'number')
		}
		for (const m of msg.matchAll(DATETIME_RE)) {
			noteVarName(key, m[1]!, 'dateOrNumber')
		}
	}

	for (const locale of Object.keys(localeValues)) {
		const map = localeValues[locale]
		for (const key of Object.keys(map)) {
			try {
				const val = map[key]
				if (Array.isArray(val)) {
					shapeByKey[key] = shapeByKey[key] ? (shapeByKey[key] === 'string' ? 'mixed' : shapeByKey[key]) : 'array'
					for (const msg of val) {
						const sanitized = sanitizeDottedArgs(msg)
						analyze(sanitized, key)
					}
				} else {
					shapeByKey[key] = shapeByKey[key] ? (shapeByKey[key] === 'array' ? 'mixed' : shapeByKey[key]) : 'string'
					const msg = sanitizeDottedArgs(val)
					analyze(msg, key)
				}
			} catch (err) {
				i18nLogger.warn?.(`Failed to parse MF2 for key "${key}" in locale "${locale}": ${String(err)}`)
			}
		}
	}

	// Compose the .d.ts content
	let buffer = `// @generated by @robojs/i18n (robo.js)\n`
	buffer += '// DO NOT EDIT — generated from /locales/**/*.json. Run `robo build` to update.\n\n'
	buffer += `export type Locale = ${locales.map((locale) => `'${locale}'`).join(' | ')}\n\n`
	buffer += `export type LocaleKey = ${keys.map((key) => `'${key}'`).join(' | ')}\n\n`

	// Array shape map and conditional return type
	buffer += `export type LocaleIsArrayMap = {\n`
	for (const key of keys) {
		const s = shapeByKey[key] ?? 'string'
		const t = s === 'array' ? 'true' : s === 'string' ? 'false' : 'boolean'
		buffer += `  '${key}': ${t},\n`
	}
	buffer += `}\n\n`

	buffer += `export type LocaleParamsMap = {\n`

	for (const key of keys) {
		const root = paramsByKey[key]
		if (!root) {
			buffer += `  '${key}': {},\n`
			continue
		}
		buffer += `  '${key}': ${emitNode(root, 2)},\n`
	}
	buffer += `}\n\n`
	buffer += `export type ParamsFor<K extends LocaleKey> = LocaleParamsMap[K]\n\n`
	buffer += `export type ReturnOf<K extends LocaleKey> = LocaleIsArrayMap[K] extends true ? string[] : string\n\n`

	return buffer
}

const undot = (s: string) => s.replaceAll(DOT_TOKEN, '.')

const tsFor = (k: TsKind): string => (k === 'number' ? 'number' : k === 'dateOrNumber' ? 'Date | number' : 'string')

const safeIdent = (s: string) => (/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(s) ? s : JSON.stringify(s))

// Prefer numeric when combined with string; any date/time widens to dateOrNumber
const widen = (a: TsKind | undefined, b: TsKind): TsKind => {
	if (!a) return b
	if (a === b) return a
	if (a === 'dateOrNumber' || b === 'dateOrNumber') return 'dateOrNumber'
	if ((a === 'number' && b === 'string') || (a === 'string' && b === 'number')) return 'number'
	return 'string'
}

function emitNode(node: Node, indent = 2): string {
	const hasChildren = !!node.children && Object.keys(node.children).length > 0

	if (!hasChildren) {
		// leaf only (scalar or unknown) – default to string if no kind recorded
		return tsFor(node.kind ?? 'string')
	}

	// build object type from children
	let objectFields = ''
	for (const [k, child] of Object.entries(node.children!)) {
		objectFields += `${' '.repeat(indent + 2)}${safeIdent(k)}?: ${emitNode(child, indent + 2)}\n`
	}
	const obj = `{\n${objectFields}${' '.repeat(indent)}}`
	return node.kind ? `${tsFor(node.kind)} | ${obj}` : obj
}
