/**
 * Portal Type Generation
 *
 * Generates the .robo/types/portal.d.ts file that provides
 * type augmentation for the portal singleton based on installed plugins.
 */

import fs from 'node:fs/promises'
import path from 'node:path'
import { extractRouteTypes, checkIfMultiple } from './extract-route-types.js'
import { logger } from '../../core/logger.js'

/**
 * Plugin route information for type generation.
 */
export interface PluginRoutes {
	/** Package name (e.g., '@robojs/discord') */
	pluginName: string
	/** Path to the plugin package */
	packagePath: string
	/** Namespace for portal access */
	namespace: string
	/** Route definitions */
	routes: RouteInfo[]
}

/**
 * Individual route information.
 */
export interface RouteInfo {
	/** Route name (inferred from filename) */
	name: string
	/** Singular accessor name (e.g., 'command' for 'commands', 'contextMenu' for 'context') */
	singular?: string
	/** Path to route source file */
	sourceFile: string
	/** Whether this route supports multiple handlers */
	multiple?: boolean
}

/**
 * Generate portal type augmentation file.
 *
 * @param plugins - Plugin route information
 * @param outputPath - Path to write the generated file
 * @param isTypeScript - Whether the project uses TypeScript
 */
export async function generatePortalTypes(
	plugins: PluginRoutes[],
	outputPath: string,
	isTypeScript: boolean
): Promise<void> {
	// Skip detailed type generation for JavaScript projects
	if (!isTypeScript) {
		await generateJavaScriptTypes(plugins, outputPath)
		return
	}

	const imports: string[] = []
	const namespaces: string[] = []

	// Track types to import from each plugin
	const typeImports: Map<string, Set<string>> = new Map()

	for (const plugin of plugins) {
		const dataTypes: string[] = []
		const controllerTypes: string[] = []

		for (const route of plugin.routes) {
			// Extract Handler and Controller types from source file
			const routeTypes = await extractRouteTypes(route.sourceFile)

			let handlerTypeString = 'unknown'
			let controllerTypeString = 'unknown'

			if (routeTypes.handler) {
				handlerTypeString = routeTypes.handler.typeName
				if (routeTypes.handler.importPath) {
					// Resolve relative imports to the plugin package name
					const resolvedPath = resolveImportPath(routeTypes.handler.importPath, plugin.pluginName, route.sourceFile)
					trackImport(typeImports, resolvedPath, routeTypes.handler.typeName)
				}
			}

			if (routeTypes.controller) {
				controllerTypeString = routeTypes.controller.typeName
				if (routeTypes.controller.importPath) {
					// Resolve relative imports to the plugin package name
					const resolvedPath = resolveImportPath(routeTypes.controller.importPath, plugin.pluginName, route.sourceFile)
					trackImport(typeImports, resolvedPath, routeTypes.controller.typeName)
				}
			}

			// Check if route has multiple: true
			const isMultiple = route.multiple ?? (await checkIfMultiple(route.sourceFile))
			const valueType = isMultiple
				? `HandlerRecord<${handlerTypeString}>[]`
				: `HandlerRecord<${handlerTypeString}>`

			// Data access (plural)
			dataTypes.push(`
      /**
       * Directory: /src/${route.name}/
       */
      ${route.name}: Record<string, ${valueType}>`)

			// Controller access (singular) - use explicit singular or derive from route name
			const singularName = route.singular ?? (route.name.endsWith('s') ? route.name.slice(0, -1) : route.name)
			controllerTypes.push(`
      /**
       * Get controller for ${route.name}
       */
      ${singularName}(name: string): ${controllerTypeString}`)
		}

		if (dataTypes.length > 0 || controllerTypes.length > 0) {
			namespaces.push(`
    /**
     * Handlers from ${plugin.pluginName}
     */
    ${plugin.namespace}: {
      // Data access (plural)${dataTypes.join('')}

      // Controller access (singular)${controllerTypes.join('')}
    }`)
		}
	}

	// Generate import statements
	// Note: import paths are already resolved when tracked via trackImport
	for (const [importPath, types] of typeImports) {
		imports.push(`import type { ${[...types].join(', ')} } from '${importPath}'`)
	}

	const content = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by Robo.js build process

import type { HandlerRecord } from 'robo.js'
${imports.join('\n')}

declare module 'robo.js' {
  interface PortalNamespaces {${namespaces.join('\n')}
  }
}
`

	// Ensure directory exists
	await fs.mkdir(path.dirname(outputPath), { recursive: true })
	await fs.writeFile(outputPath, content, 'utf-8')

	logger.debug(`Generated portal types at ${outputPath}`)
}

/**
 * Generate simplified types for JavaScript projects.
 */
async function generateJavaScriptTypes(plugins: PluginRoutes[], outputPath: string): Promise<void> {
	const namespaces: string[] = []

	for (const plugin of plugins) {
		const routeTypes = plugin.routes.map((route) => {
			return `      ${route.name}: Record<string, HandlerRecord<unknown>>`
		})

		if (routeTypes.length > 0) {
			namespaces.push(`
    ${plugin.namespace}: {
${routeTypes.join('\n')}
    }`)
		}
	}

	const content = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by Robo.js build process

import type { HandlerRecord } from 'robo.js'

declare module 'robo.js' {
  interface PortalNamespaces {${namespaces.join('\n')}
  }
}
`

	// Ensure directory exists
	await fs.mkdir(path.dirname(outputPath), { recursive: true })
	await fs.writeFile(outputPath, content, 'utf-8')

	logger.debug(`Generated portal types (JavaScript mode) at ${outputPath}`)
}

/**
 * Track a type import for later generation.
 */
function trackImport(typeImports: Map<string, Set<string>>, importPath: string, typeName: string): void {
	if (!typeImports.has(importPath)) {
		typeImports.set(importPath, new Set())
	}
	typeImports.get(importPath)!.add(typeName)
}

/**
 * Resolve an import path for the generated file.
 * Converts relative paths to the plugin's package name.
 *
 * @param importPath - The import path from the source file
 * @param pluginName - The plugin package name (e.g., '@robojs/discord')
 * @param sourceFile - The source file where the import is from
 */
function resolveImportPath(importPath: string, pluginName: string, _sourceFile: string): string {
	// If it's already a package import (not relative), return as-is
	if (!importPath.startsWith('.') && !importPath.startsWith('/')) {
		return importPath
	}

	// For relative imports from plugin source files, use the plugin package name
	// This works because plugin types are typically re-exported from the main entry point
	// e.g., import { CommandHandler } from '@robojs/discord'
	return pluginName
}

/**
 * Generate the types index file that references portal types.
 */
export async function generateTypesIndex(outputDir: string): Promise<void> {
	const indexPath = path.join(outputDir, 'index.d.ts')

	const content = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by Robo.js build process

/// <reference path="./portal.d.ts" />
`

	await fs.mkdir(outputDir, { recursive: true })
	await fs.writeFile(indexPath, content, 'utf-8')

	logger.debug(`Generated types index at ${indexPath}`)
}

/** Supported file extensions for route files */
const ROUTE_EXTENSIONS = ['.ts', '.tsx', '.mts', '.js', '.jsx', '.mjs']

/**
 * Find a route source file with any supported extension.
 */
async function findRouteSourceFile(basePath: string, routeName: string): Promise<string | null> {
	for (const ext of ROUTE_EXTENSIONS) {
		const filePath = path.join(basePath, `${routeName}${ext}`)
		try {
			await fs.access(filePath)
			return filePath
		} catch {
			// Try next extension
		}
	}
	return null
}

/**
 * Collect plugin routes for type generation.
 * Called during build to gather all route information.
 */
export async function collectPluginRoutes(
	plugins: Array<{ name: string; path: string; namespace: string }>,
	routeDefinitions: Record<string, { routes: Record<string, { directory: string; multiple?: boolean; singular?: string }> }>
): Promise<PluginRoutes[]> {
	const result: PluginRoutes[] = []

	for (const plugin of plugins) {
		const namespaceDef = routeDefinitions[plugin.namespace]
		if (!namespaceDef) continue

		const routes: RouteInfo[] = []

		for (const [routeName, routeConfig] of Object.entries(namespaceDef.routes)) {
			// Find the route source file (try multiple extensions)
			const routesDir = path.join(plugin.path, 'src', 'robo', 'routes')
			const routeSourcePath = await findRouteSourceFile(routesDir, routeName)

			if (routeSourcePath) {
				routes.push({
					name: routeName,
					singular: routeConfig.singular,
					sourceFile: routeSourcePath,
					multiple: routeConfig.multiple
				})
			} else {
				logger.debug(`Route source not found: ${routesDir}/${routeName}.[ts|js|...]`)
			}
		}

		if (routes.length > 0) {
			result.push({
				pluginName: plugin.name,
				packagePath: plugin.path,
				namespace: plugin.namespace,
				routes
			})
		}
	}

	return result
}
