/**
 * Manifest Type Generator
 *
 * Generates .robo/types/manifest.d.ts with type-safe maps
 * for routes, hooks, configs, and metadata.
 */

import fs from 'node:fs/promises'
import path from 'node:path'
import { logger } from '../../core/logger.js'
import type { DiscoveredRoute, RouteEntries } from '../../types/routes.js'
import type { HooksManifest, PluginRegistry } from '../../types/manifest-v1.js'

export interface GenerateManifestTypesOptions {
	/** Discovered route definitions */
	routes: DiscoveredRoute[]
	/** Processed route entries */
	routeEntries: RouteEntries
	/** Hook entries */
	hooks: HooksManifest
	/** Plugin registry */
	plugins: PluginRegistry
}

/**
 * Generate .robo/types/manifest.d.ts with typed maps.
 */
export async function generateManifestTypes(options: GenerateManifestTypesOptions): Promise<void> {
	const { routes, routeEntries, hooks, plugins } = options

	const lines: string[] = [
		'// AUTO-GENERATED FILE - DO NOT EDIT',
		'// Generated by Robo.js build process',
		'',
		"import type { HookEntry, AggregatedMetadata } from 'robo.js'",
		''
	]

	// Generate ManifestRouteMap
	lines.push('declare module "robo.js" {')
	lines.push('  /**')
	lines.push('   * Available route namespaces and their routes.')
	lines.push('   * Generated from installed plugins.')
	lines.push('   */')
	lines.push('  interface ManifestRouteMap {')

	const namespaceRoutes = groupRoutesByNamespace(routes)
	for (const [namespace, routeNames] of Object.entries(namespaceRoutes)) {
		const routeUnion = routeNames.map((r) => `'${r}'`).join(' | ')
		lines.push(`    ${safeKey(namespace)}: ${routeUnion}`)
	}

	lines.push('  }')
	lines.push('')

	// Generate ManifestHookMap
	lines.push('  /**')
	lines.push('   * Available lifecycle hooks.')
	lines.push('   */')
	lines.push('  interface ManifestHookMap {')

	const hookTypes = Object.keys(hooks)
	for (const hookType of hookTypes) {
		lines.push(`    ${safeKey(hookType)}: HookEntry`)
	}

	// Add standard hooks if not present
	const standardHooks = ['setup', 'init', 'start', 'stop', 'build']
	for (const hook of standardHooks) {
		if (!hookTypes.includes(hook)) {
			lines.push(`    ${hook}: HookEntry`)
		}
	}

	lines.push('  }')
	lines.push('')

	// Generate ManifestConfigMap
	lines.push('  /**')
	lines.push('   * Plugin configuration types.')
	lines.push('   */')
	lines.push('  interface ManifestConfigMap {')

	for (const pluginName of Object.keys(plugins)) {
		lines.push(`    '${pluginName}': Record<string, unknown>`)
	}

	lines.push('  }')
	lines.push('')

	// Generate ManifestMetadataMap
	lines.push('  /**')
	lines.push('   * Aggregated metadata types per namespace.')
	lines.push('   */')
	lines.push('  interface ManifestMetadataMap {')

	for (const namespace of Object.keys(namespaceRoutes)) {
		lines.push(`    ${safeKey(namespace)}: AggregatedMetadata`)
	}

	lines.push('  }')
	lines.push('}')
	lines.push('')

	// Write the file
	const typesDir = path.join(process.cwd(), '.robo', 'types')
	await fs.mkdir(typesDir, { recursive: true })

	const outputPath = path.join(typesDir, 'manifest.d.ts')
	await fs.writeFile(outputPath, lines.join('\n'))

	logger.debug(`Generated manifest types at ${outputPath}`)
}

/**
 * Group routes by namespace.
 */
function groupRoutesByNamespace(routes: DiscoveredRoute[]): Record<string, string[]> {
	const result: Record<string, string[]> = {}

	for (const route of routes) {
		if (!result[route.namespace]) {
			result[route.namespace] = []
		}
		result[route.namespace].push(route.name)
	}

	return result
}

/**
 * Make a key safe for TypeScript interface property.
 */
function safeKey(key: string): string {
	// If the key is a valid identifier, return as-is
	if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)) {
		return key
	}
	// Otherwise, quote it
	return `'${key}'`
}
