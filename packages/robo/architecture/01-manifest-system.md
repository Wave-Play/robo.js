# Manifest System

The manifest system is the backbone of Robo.js's file-based routing. It bridges build-time file scanning with runtime handler loading, enabling the "zero-config" magic where files in specific directories automatically become functional handlers.

## Manifest Structure

The manifest is stored at `/.robo/manifest.json` and contains all metadata needed to load and execute handlers at runtime.

### Type Definition

From `src/types/manifest.ts`:

```typescript
interface Manifest {
  __README: string                              // Warning about auto-generation
  __robo: {
    config: Config | null                       // Redacted project config
    language: 'javascript' | 'typescript'       // Project language
    mode: string                                // Build mode (production/development)
    seed?: ManifestSeed                         // Seed configuration for plugins
    type: 'plugin' | 'robo'                     // Project type
    updatedAt?: string                          // Last build timestamp
    version?: string                            // Robo.js version
  }
  api: Record<string, ApiEntry>                 // API route handlers
  commands: Record<string, CommandEntry>        // Slash command handlers
  context: {
    message: Record<string, ContextEntry>       // Message context menus
    user: Record<string, ContextEntry>          // User context menus
  }
  events: Record<string, EventConfig[]>         // Event handlers (arrays for multiple)
  permissions?: PermissionsString[] | number    // Required Discord permissions
  middleware?: MiddlewareEntry[]                // Middleware handlers
  scopes?: Scope[]                              // OAuth2 scopes
}
```

### Entry Types

Each handler type has its own entry structure:

```typescript
// Base config shared by all entries
interface BaseConfig {
  __auto?: true                    // Generated by Robo (e.g., default commands)
  __module?: string                // Module name if from /modules
  __path?: string                  // Relative path to compiled handler
  __plugin?: {                     // Plugin info if from a plugin
    name: string
    path: string
  }
  description?: string
  timeout?: number
}

// Command entries support subcommands
interface CommandEntry extends CommandConfig {
  subcommands?: Record<string, CommandEntry>
}

// API entries support nested routes
interface ApiEntry extends BaseConfig {
  subroutes?: Record<string, ApiEntry>
}

// Events are arrays (multiple handlers per event)
interface EventConfig extends BaseConfig {
  frequency?: 'always' | 'once'
}
```

### Sample Manifest

```json
{
  "__README": "This file was automatically generated by Robo.js - do not edit manually.",
  "__robo": {
    "config": { "clientOptions": { "intents": [] }, "plugins": [] },
    "language": "typescript",
    "mode": "production",
    "type": "robo",
    "updatedAt": "2025-11-19T07:34:13.349Z",
    "version": "0.10.31"
  },
  "api": {
    "health": {
      "__path": "/.robo/build/api/health.js"
    },
    "users": {
      "__path": "/.robo/build/api/users/index.js",
      "subroutes": {
        "[id]": {
          "__path": "/.robo/build/api/users/[id].js"
        }
      }
    }
  },
  "commands": {
    "ping": {
      "__path": "/.robo/build/commands/ping.js",
      "description": "Check bot latency"
    },
    "admin": {
      "subcommands": {
        "ban": {
          "__path": "/.robo/build/commands/admin/ban.js",
          "description": "Ban a user"
        }
      }
    }
  },
  "context": {
    "message": {},
    "user": {
      "User Info": {
        "__path": "/.robo/build/context/user/User Info.js"
      }
    }
  },
  "events": {
    "ready": [
      { "__path": "/.robo/build/events/ready.js" }
    ],
    "_start": [
      { "__path": "/.robo/build/events/_start.js" },
      { 
        "__path": "/.robo/build/events/_start.js",
        "__plugin": { "name": "@robojs/server", "path": "node_modules/@robojs/server" }
      }
    ]
  },
  "permissions": ["SendMessages", "ViewChannel"],
  "middleware": [
    { "__path": "/.robo/build/middleware/logger.js" }
  ],
  "scopes": ["bot", "applications.commands"]
}
```

## Build-Time Generation

Manifest generation happens during `robo build` in `src/cli/utils/manifest.ts`.

### Generation Flow

```
generateManifest()
      ↓
loadConfig() - Load project config
      ↓
readPluginManifest() - Load and merge plugin manifests
      ↓
generateEntries() for each type:
  - api
  - commands
  - context
  - events
  - middleware
      ↓
generatePermissions() - Compute required permissions
      ↓
generateScopes() - Compute OAuth2 scopes
      ↓
Write to /.robo/manifest.json
```

### The `generateEntries` Function

This is the core function that scans directories and creates manifest entries:

```typescript
async function generateEntries<T>(
  type: 'api' | 'commands' | 'context' | 'events' | 'middleware',
  generatedKeys: string[]    // Keys of auto-generated handlers
): Promise<Record<string, T>> {
  const entries: Record<string, T> = {}
  
  await scanDir(
    async (fileKeys, fullPath, moduleKeys) => {
      // Import the handler module to read its config
      const module = await import(fullPath)
      
      // Create entry with metadata
      let entry = {
        ...getValue(type, module.config),
        __auto: generatedKeys.includes(fileKeys.join('/')) ? true : undefined,
        __module: moduleKeys.join('/') || undefined,
        __path: fullPath.replace(process.cwd(), '')
      }
      
      // Handle different entry types...
      if (type === 'events') {
        // Events are arrays
        entries[fileKeys[0]] = entries[fileKeys[0]] || []
        entries[fileKeys[0]].push(entry)
      } else if (type === 'commands' && fileKeys.length === 2) {
        // Subcommand nesting
        entries[fileKeys[0]] = entries[fileKeys[0]] || { subcommands: {} }
        entries[fileKeys[0]].subcommands[fileKeys[1]] = entry
      }
      // ... more type-specific logic
    },
    { type }
  )
  
  return entries
}
```

### The `scanDir` Function

Recursively walks build directories to find handlers:

```typescript
async function scanDir(predicate: ScanDirPredicate, options: ScanDirOptions) {
  const { recursionKeys = [], recursionModuleKeys = [], type } = options
  
  // Determine directory path
  let directoryPath = path.join(process.cwd(), '.robo', 'build', type)
  
  // Read directory contents
  const directory = await fs.readdir(directoryPath)
  
  // Separate files and directories
  const files: string[] = []
  const directories: string[] = []
  
  await Promise.all(directory.map(async (file) => {
    const stats = await fs.stat(path.join(directoryPath, file))
    if (stats.isFile() && ALLOWED_EXTENSIONS.includes(path.extname(file))) {
      files.push(file)
    } else if (stats.isDirectory()) {
      directories.push(file)
    }
  }))
  
  // Also scan /modules directory
  const modules = await scanModulesDirectory()
  
  // Process files first (parent entries before children)
  await Promise.all(files.map(async (file) => {
    const fileKeys = [...recursionKeys, path.basename(file, path.extname(file))]
    const fullPath = path.resolve(directoryPath, file)
    return predicate(fileKeys, fullPath, recursionModuleKeys)
  }))
  
  // Then recurse into directories
  await Promise.all(directories.map(async (childDir) => {
    return scanDir(predicate, {
      recursionKeys: [...recursionKeys, childDir],
      recursionPath: path.resolve(directoryPath, childDir),
      type
    })
  }))
}
```

### Extracting Handler Config

When scanning files, the `config` export is read to populate manifest entries:

```typescript
function getValue<T>(type: string, config: BaseConfig): T {
  const value = {} as T
  
  if (type === 'commands' && config) {
    if (config.description) value.description = config.description
    if (config.options) value.options = config.options.map(...)
    if (config.defaultMemberPermissions) value.defaultMemberPermissions = ...
    // ... more command-specific fields
  }
  
  if (type === 'events' && config) {
    value.frequency = config.frequency ?? 'always'
  }
  
  return value
}
```

### Plugin Manifest Merging

When generating the project manifest, plugin manifests are loaded and merged:

```typescript
async function readPluginManifest(plugins: Plugin[]): Promise<Manifest> {
  let pluginsManifest = BASE_MANIFEST
  
  for (const plugin of plugins) {
    const pluginName = typeof plugin === 'string' ? plugin : plugin[0]
    const packagePath = await findPackagePath(pluginName, process.cwd())
    
    // Load plugin's manifest
    const manifest = await Compiler.useManifest({
      basePath: packagePath,
      name: pluginName
    })
    
    // Merge into combined manifest
    pluginsManifest = {
      ...pluginsManifest,
      api: { ...pluginsManifest.api, ...manifest.api },
      commands: { ...pluginsManifest.commands, ...manifest.commands },
      context: {
        message: { ...pluginsManifest.context.message, ...manifest.context.message },
        user: { ...pluginsManifest.context.user, ...manifest.context.user }
      },
      events: mergeEvents(pluginsManifest.events, manifest.events),
      middleware: [...pluginsManifest.middleware, ...manifest.middleware],
      permissions: [...pluginsManifest.permissions, ...manifest.permissions],
      scopes: [...pluginsManifest.scopes, ...manifest.scopes]
    }
  }
  
  return pluginsManifest
}
```

### Plugin Metadata Injection

When loading a plugin manifest, the `__plugin` metadata is injected:

```typescript
// In src/cli/compiler/manifest.ts
if (name && basePath) {
  const pluginInfo = {
    __auto: true,
    __plugin: { name, path: basePath }
  }
  
  // Inject into all entries
  Object.keys(manifest.commands).forEach((key) => {
    manifest.commands[key].__plugin = { name, path: basePath }
  })
  
  Object.keys(manifest.events).forEach((key) => {
    manifest.events[key] = manifest.events[key].map((eventConfig) => ({
      ...pluginInfo,
      ...eventConfig
    }))
  })
  // ... same for api, context, middleware
}
```

## Runtime Loading

At runtime, the manifest is loaded via `Compiler.useManifest()` in `src/cli/compiler/manifest.ts`.

### The `useManifest` Function

```typescript
async function useManifest(options?: UseManifestOptions): Promise<Manifest> {
  const { cache = true, name = '', basePath = '', safe } = options ?? {}
  
  // Check cache first
  let manifest = ManifestCache[name]
  if (manifest && cache) {
    return manifest
  }
  
  // Load from file
  const manifestPath = path.join(basePath || '.', '.robo', 'manifest.json')
  const manifestContent = await fs.readFile(manifestPath, 'utf-8')
  manifest = JSON.parse(manifestContent, jsonReviver)
  
  // Inject plugin info if loading as plugin
  if (name && basePath) {
    // ... inject __plugin metadata
  }
  
  // Cache and return
  ManifestCache[name] = manifest
  return manifest
}
```

### JSON Reviver for BigInt

Discord permissions can be BigInt values, requiring special handling:

```typescript
function jsonReviver(key: string, value: unknown) {
  if (key === 'defaultMemberPermissions' && typeof value === 'string' && value.slice(-1) === 'n') {
    return BigInt(value.slice(0, -1))
  }
  return value
}

// Corresponding replacer for serialization
function jsonReplacer(key: string, value: unknown) {
  if (key === 'defaultMemberPermissions' && typeof value === 'bigint') {
    return value.toString() + 'n'
  }
  return value
}
```

### Loading Handlers from Manifest

The Portal uses the manifest to dynamically import handlers:

```typescript
async function loadHandlerRecords<T>(type: string) {
  const collection = new Collection<string, T>()
  const manifest = Compiler.getManifest()
  
  const scanPredicate = async (entry: BaseConfig, entryKeys) => {
    if (!entry.__path) return  // Skip nested entries without path
    
    // Compute import path
    const basePath = path.join(process.cwd(), entry.__plugin?.path ?? '.')
    const importPath = pathToFileURL(path.join(basePath, entry.__path)).toString()
    
    // Create handler record
    const handler: HandlerRecord = {
      auto: entry.__auto,
      description: entry.description,
      handler: await import(importPath),  // Dynamic import!
      key: entryKeys.join('/'),
      module: entry.__module,
      path: entry.__path,
      plugin: entry.__plugin,
      type: type
    }
    
    // Add to collection based on type
    if (type === 'events') {
      collection.get(entryKeys[0])?.push(handler) ?? collection.set(entryKeys[0], [handler])
    } else {
      collection.set(entryKeys.join(' '), handler)
    }
  }
  
  await scanEntries(scanPredicate, { manifestEntries: manifest[type], type })
  return collection
}
```

## Caching Behavior

### Build-Time Caching

The manifest is regenerated on every build. However, during development with `robo dev`, incremental builds only recompile changed files.

### Runtime Caching

Manifests are cached in memory after first load:

```typescript
const ManifestCache: Record<string, Manifest> = {}

// Cached access
const manifest = ManifestCache[name]
if (manifest && cache) {
  return manifest
}
```

The cache key is the plugin name (empty string for the main project).

### Safe Loading

The `safe` option allows graceful handling of missing manifests:

```typescript
try {
  const manifestContent = await fs.readFile(manifestPath, 'utf-8')
  manifest = JSON.parse(manifestContent)
} catch (e) {
  if (safe || e.code === 'ENOENT') {
    manifest = BASE_MANIFEST  // Return empty manifest
  } else {
    throw e
  }
}
```

## Base Manifest

The default empty manifest structure:

```typescript
const BASE_MANIFEST: Manifest = {
  __README: 'This file was automatically generated by Robo.js - do not edit manually.',
  __robo: {
    config: null,
    language: 'javascript',
    mode: Mode.get(),
    type: 'robo'
  },
  api: {},
  commands: {},
  context: { message: {}, user: {} },
  events: {},
  permissions: [],
  middleware: [],
  scopes: []
}
```

## Key Observations for Decoupling

1. **Manifest is framework-agnostic in structure** - The core structure (entries with paths, metadata) doesn't inherently require Discord.js

2. **Discord-specific fields are embedded** - Fields like `defaultMemberPermissions`, `dmPermission`, `contexts`, `integrationTypes` are Discord-specific

3. **Handler types are hardcoded** - The five types (api, commands, context, events, middleware) are fixed in the manifest structure

4. **Plugin injection is centralized** - The `__plugin` metadata injection happens in one place, making it extensible

5. **Scanning is directory-based** - The `scanDir` function could be generalized to scan arbitrary directories defined by plugins

6. **Permissions/scopes are Discord-specific** - The `permissions` and `scopes` arrays are Discord OAuth2 concepts

7. **Events array allows multiple handlers** - This pattern could support multiple integrations listening to the same event

